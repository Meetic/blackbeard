---
title: "Playbooks"
date: 2018-07-19T12:42:17+01:00
anchor: "playbooks"
weight: 30
---

Blackbeard uses `Playbooks` to manage technical stack deployments across multiple namespaces.

A Playbook is organized as a collection of files inside of a directory. Inside of this directory, Blackbeard will expect a structure that matches this:

* A `templates` directory, containing Kubernetes manifests, written as templates. Those are typical configuration files for K8s (yaml).
* A `defaults.json` file, defining the default values to apply (to the manifest templates)
* An `inventories` directory that will contains the future inventories (One per namespace). The content of this directory should not be versioned. Inventories are variance of the `defaults.json` file.
* A `configs` directory that will contains the future manifests files (one sub-dir per namespace). The content of this directory should not be versioned as well. Manifests are generated by applying the `inventory` values to the `template`

By default, Blackbeard will try to use the current directory as a Playbook. You can also specify a default playbook using a configuration file.

Thus, a Playbook made for an application called *"MyApp"* will look like :

```sh
MyApp
├── README.md
├── configs                                     #Directory containing generated manifest for each inventory
│   ├── john                                    #john is a namespace
│   │   ├── api.yml                             #Kubernetes manifest containing deployments and services for the api app.
│   │   └── front.yml                           #Kubernetes manifest containing deployments and services for the front-end app.
│   └── awesome-feature-to-test                 #awesome-feature-to-test is a namespace
│       ├── api.yml
│       └── front.yml
├── defaults.json                               #Default inventory file
├── inventories                                 #Directory containing inventories for each namespace
│   ├── john_inventory.json                     #inventory for john namespace
│   └── awesome-feature-to-test_inventory.json  #inventory for awesome-feature-to-test namespace
└── templates                                   #Directory containing the Kubernetes manifest templates
    ├── api.yml.tpl
    └── front.yml.tpl
```

{{% block info %}}
On this example, you can see the stack contains an API and a front-end application and is deployed on 2 namespaces :

* One called *john* is used by john for development purpose
* One called *awesome-feature-to-test* is used for testing a feature on an isolated

{{% /block %}}